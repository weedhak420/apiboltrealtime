<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏£‡∏ñ‡πÅ‡∏ó‡πá‡∏Å‡∏ã‡∏µ‡πà - Multi-location Real-time Tracking</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        #header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        #header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 20px;
        }

        #title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #title h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #header-controls {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        #stats-panel {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        #filters-panel {
            display: flex;
            gap: 16px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-group label {
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group select {
            min-width: 180px;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: white;
            font-weight: 600;
            color: #334155;
            box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .filter-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 800;
            color: #1e293b;
        }

        .stat-value.highlight {
            color: #667eea;
        }

        .stat-subtext {
            font-size: 10px;
            color: #94a3b8;
            margin-top: 2px;
        }

        #connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        #connection-status.connected {
            background: #dcfce7;
            color: #166534;
        }

        #connection-status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.connected { background: #22c55e; }
        .status-dot.disconnected { background: #ef4444; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        #map-container {
            flex: 1;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            animation: fadeIn 0.5s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .vehicle-popup h3 {
            margin: 0 0 8px 0;
            color: #1e293b;
            font-size: 16px;
            font-weight: 700;
        }

        .vehicle-popup p {
            margin: 4px 0;
            color: #64748b;
            font-size: 13px;
        }

        #debug-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
        }

        #debug-toggle:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
        }

        #debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        #debug-panel h4 {
            margin: 0 0 12px 0;
            color: #00ff00;
            font-size: 14px;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 8px;
        }

        #debug-panel pre {
            margin: 8px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.6;
        }

        .debug-hidden {
            display: none;
        }

        @media (max-width: 768px) {
            #container {
                padding: 10px;
                gap: 10px;
            }

            #header {
                padding: 15px 20px;
            }

            #header-content {
                flex-direction: column;
            }

            #header-controls {
                width: 100%;
                flex-direction: column;
                gap: 16px;
            }

            #stats-panel {
                width: 100%;
                justify-content: space-around;
            }

            #filters-panel {
                width: 100%;
            }

            .stat-value {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="header-content">
                <div id="title">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
                        <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="#667eea"/>
                        <path d="M2 17L12 22L22 17M2 12L12 17L22 12" stroke="#764ba2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <h1>üöï ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏£‡∏ñ‡πÅ‡∏ó‡πá‡∏Å‡∏ã‡∏µ‡πà</h1>
                </div>

                <div id="header-controls">
                    <div id="stats-panel">
                        <div class="stat-item">
                            <span class="stat-label">‡∏£‡∏ñ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</span>
                            <span class="stat-value highlight" id="vehicle-count">0</span>
                            <span class="stat-subtext" id="vehicle-count-subtext">visible / total</span>
                        </div>

                        <div class="stat-item">
                            <span class="stat-label">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°</span>
                            <span class="stat-value" id="location-count">0</span>
                            <span class="stat-subtext">locations</span>
                        </div>

                        <div class="stat-item">
                            <span class="stat-label">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</span>
                            <span class="stat-value" id="fetch-time">-</span>
                            <span class="stat-subtext">seconds</span>
                        </div>

                        <div class="stat-item">
                            <span class="stat-label">‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</span>
                            <span class="stat-value" style="font-size: 16px;" id="last-update">-</span>
                        </div>

                        <div id="connection-status" class="disconnected">
                            <span class="status-dot disconnected"></span>
                            <span id="connection-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠...</span>
                        </div>
                    </div>

                    <div id="filters-panel">
                        <div class="filter-group">
                            <label for="district-filter">‡∏≠‡∏≥‡πÄ‡∏†‡∏≠</label>
                            <select id="district-filter">
                                <option value="all">‡∏ó‡∏∏‡∏Å‡∏≠‡∏≥‡πÄ‡∏†‡∏≠</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="type-filter">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà</label>
                            <select id="type-filter">
                                <option value="all">‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="map-container">
            <div id="map"></div>
        </div>
    </div>

    <button id="debug-toggle" onclick="toggleDebug()">üêõ Debug</button>
    <div id="debug-panel" class="debug-hidden">
        <h4>üìä Debug Information</h4>
        <div id="debug-content"></div>
    </div>

    <script>
        // Configuration
        const FALLBACK_MAP_CENTER = [18.7883, 98.9853];
        const FALLBACK_MAP_ZOOM = 12;

        let debugVisible = false;
        let debugLogs = [];
        let markers = {};
        let latestVehicles = [];
        let locationMetadata = [];
        let selectedDistrict = 'all';
        let selectedLocationType = 'all';
        let lastLocationsCount = 0;
        let lastFetchTime = 0;
        let lastTotalVehicleCount = 0;
        let mapConfigured = false;
        let mapSettings = {
            center: { lat: FALLBACK_MAP_CENTER[0], lng: FALLBACK_MAP_CENTER[1] },
            zoom: FALLBACK_MAP_ZOOM,
        };
        let filtersInitialized = false;

        const districtFilter = document.getElementById('district-filter');
        const typeFilter = document.getElementById('type-filter');

        function toggleDebug() {
            debugVisible = !debugVisible;
            const panel = document.getElementById('debug-panel');
            const button = document.getElementById('debug-toggle');

            if (debugVisible) {
                panel.classList.remove('debug-hidden');
                button.textContent = '‚ùå ‡∏ã‡πà‡∏≠‡∏ô';
            } else {
                panel.classList.add('debug-hidden');
                button.textContent = 'üêõ Debug';
            }
        }

        function addDebugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString('th-TH');
            const logEntry = `[${timestamp}] ${message}`;

            console.log('[Bolt]', message, data || '');

            debugLogs.unshift(logEntry);
            if (data) {
                debugLogs.unshift(JSON.stringify(data, null, 2));
            }

            if (debugLogs.length > 50) {
                debugLogs = debugLogs.slice(0, 50);
            }

            const debugContent = document.getElementById('debug-content');
            if (debugContent) {
                debugContent.innerHTML = '<pre>' + debugLogs.join('\n') + '</pre>';
            }
        }

        function formatLocationLabel(location) {
            if (!location) {
                return 'N/A';
            }

            const name = location.name || {};
            const isNameObject = typeof name === 'object' && name !== null;
            const nameTh = isNameObject ? name.th : undefined;
            const nameEn = isNameObject ? name.en : undefined;
            const labelParts = [];
            if (nameTh) {
                labelParts.push(nameTh);
            }
            if (nameEn && nameEn !== nameTh) {
                labelParts.push(nameEn);
            }
            if (!labelParts.length && typeof name === 'string') {
                labelParts.push(name);
            }
            if (!labelParts.length && location.id) {
                labelParts.push(location.id);
            }
            const districtText = location.district ? ` ‚Ä¢ ${location.district}` : '';
            return `${labelParts.join(' / ') || 'Unknown'}${districtText}`;
        }

        function applyMapSettings(settings, options = {}) {
            if (!settings || !settings.center) {
                return;
            }

            const { force = false } = options;
            const lat = Number(settings.center.lat);
            const lng = Number(settings.center.lng);
            const zoom = Number(settings.zoom);

            if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                return;
            }

            if (!mapConfigured || force) {
                map.setView([lat, lng], Number.isFinite(zoom) ? zoom : map.getZoom());
                mapConfigured = true;
            }
        }

        function populateDistrictFilter(districts) {
            if (!districtFilter || !Array.isArray(districts)) {
                return;
            }

            const previousValue = districtFilter.value || selectedDistrict;
            districtFilter.innerHTML = '<option value="all">‡∏ó‡∏∏‡∏Å‡∏≠‡∏≥‡πÄ‡∏†‡∏≠</option>';
            districts.forEach((district) => {
                const option = document.createElement('option');
                option.value = district;
                option.textContent = district;
                districtFilter.appendChild(option);
            });
            const newValue = districts.includes(previousValue) ? previousValue : 'all';
            districtFilter.value = newValue;
            selectedDistrict = newValue;
        }

        function populateTypeFilter(types) {
            if (!typeFilter || !Array.isArray(types)) {
                return;
            }

            const previousValue = typeFilter.value || selectedLocationType;
            typeFilter.innerHTML = '<option value="all">‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</option>';
            types.forEach((type) => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                typeFilter.appendChild(option);
            });
            const newValue = types.includes(previousValue) ? previousValue : 'all';
            typeFilter.value = newValue;
            selectedLocationType = newValue;
        }

        function applyFilters(vehicles) {
            return vehicles.filter((vehicle) => {
                const location = vehicle.source_location || {};
                const districtMatch = selectedDistrict === 'all' || location.district === selectedDistrict;
                const typeMatch = selectedLocationType === 'all' || location.type === selectedLocationType;
                return districtMatch && typeMatch;
            });
        }

        function handleFilterChange(kind, value) {
            if (kind === 'district') {
                selectedDistrict = value;
            } else if (kind === 'type') {
                selectedLocationType = value;
            }

            const label = kind === 'district' ? '‡∏≠‡∏≥‡πÄ‡∏†‡∏≠' : '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà';
            addDebugLog(`üéõÔ∏è ${label} filter: ${value === 'all' ? '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' : value}`);

            const filteredVehicles = applyFilters(latestVehicles);
            updateVehicles(filteredVehicles);
            updateStats(filteredVehicles.length, lastLocationsCount, lastFetchTime, lastTotalVehicleCount);
        }

        // Initialize map
        addDebugLog('üó∫Ô∏è Initializing map...');
        const map = L.map('map').setView(FALLBACK_MAP_CENTER, FALLBACK_MAP_ZOOM);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        addDebugLog('‚úÖ Map initialized');

        async function loadLocationMetadata() {
            try {
                const response = await fetch('/locations');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                locationMetadata = data.locations || [];
                if (data.map_settings) {
                    mapSettings = data.map_settings;
                    applyMapSettings(mapSettings, { force: true });
                }
                if (Array.isArray(data.districts)) {
                    populateDistrictFilter(data.districts);
                }
                if (Array.isArray(data.types)) {
                    populateTypeFilter(data.types);
                }
                if (districtFilter) {
                    selectedDistrict = districtFilter.value;
                }
                if (typeFilter) {
                    selectedLocationType = typeFilter.value;
                }
                filtersInitialized = true;
                addDebugLog('üóÇÔ∏è Loaded location metadata', {
                    districts: Array.isArray(data.districts) ? data.districts.length : 0,
                    types: Array.isArray(data.types) ? data.types.length : 0,
                });
            } catch (error) {
                addDebugLog('‚ùå Failed to load location metadata: ' + error.message);
            }
        }

        loadLocationMetadata();

        if (districtFilter) {
            districtFilter.addEventListener('change', (event) => {
                handleFilterChange('district', event.target.value);
            });
        }

        if (typeFilter) {
            typeFilter.addEventListener('change', (event) => {
                handleFilterChange('type', event.target.value);
            });
        }

        // Socket.IO connection
        addDebugLog('üîå Connecting to Socket.IO...');
        const socket = io({
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionAttempts: 10
        });

        socket.on('connect', () => {
            addDebugLog('‚úÖ Socket connected!');
            updateConnectionStatus(true);
        });

        socket.on('disconnect', () => {
            addDebugLog('‚ùå Socket disconnected');
            updateConnectionStatus(false);
        });

        socket.on('connect_error', (error) => {
            addDebugLog('‚ùå Connection error: ' + error.message);
            updateConnectionStatus(false);
        });

        socket.on('vehicles_update', (data) => {
            addDebugLog('üì° Received vehicles update');

            if (Array.isArray(data.location_metadata) && data.location_metadata.length > 0) {
                locationMetadata = data.location_metadata;
            }

            if (data.config) {
                if (data.config.map) {
                    mapSettings = data.config.map;
                    applyMapSettings(mapSettings);
                }
                if (!filtersInitialized) {
                    if (Array.isArray(data.config.districts)) {
                        populateDistrictFilter(data.config.districts);
                    }
                    if (Array.isArray(data.config.types)) {
                        populateTypeFilter(data.config.types);
                    }
                    if (districtFilter) {
                        selectedDistrict = districtFilter.value;
                    }
                    if (typeFilter) {
                        selectedLocationType = typeFilter.value;
                    }
                    filtersInitialized = true;
                }
            }

            const vehicles = Array.isArray(data.vehicles) ? data.vehicles : [];
            latestVehicles = vehicles;
            lastTotalVehicleCount = vehicles.length;
            lastLocationsCount = data.locations_count || (Array.isArray(locationMetadata) ? locationMetadata.length : 0);
            const fetchTime = typeof data.fetch_time === 'number' ? data.fetch_time : parseFloat(data.fetch_time) || 0;
            lastFetchTime = fetchTime;

            const filteredVehicles = applyFilters(latestVehicles);
            const filtersApplied = selectedDistrict !== 'all' || selectedLocationType !== 'all';
            const filterSummary = filtersApplied ? ` (${filteredVehicles.length}/${vehicles.length} shown)` : '';
            addDebugLog(`üìä Stats: ${vehicles.length} vehicles${filterSummary}, ${lastLocationsCount} locations, ${fetchTime.toFixed(2)}s`);

            if (filteredVehicles.length > 0) {
                addDebugLog('üöó First vehicle sample:', filteredVehicles[0]);
            }

            updateVehicles(filteredVehicles);
            updateStats(filteredVehicles.length, lastLocationsCount, fetchTime, vehicles.length);

            lastUpdateTime = Date.now();
        });

        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            const textEl = document.getElementById('connection-text');
            const dotEl = statusEl.querySelector('.status-dot');

            if (connected) {
                statusEl.className = 'connected';
                textEl.textContent = '‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß';
                dotEl.className = 'status-dot connected';
            } else {
                statusEl.className = 'disconnected';
                textEl.textContent = '‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠';
                dotEl.className = 'status-dot disconnected';
            }
        }

        function updateVehicles(vehicles) {
            const currentIds = new Set();
            let markersCreated = 0;
            let markersUpdated = 0;

            vehicles.forEach((vehicle) => {
                if (!vehicle.id || !vehicle.lat || !vehicle.lng) {
                    return;
                }

                currentIds.add(vehicle.id);

                if (markers[vehicle.id]) {
                    const marker = markers[vehicle.id];
                    const newLatLng = L.latLng(vehicle.lat, vehicle.lng);
                    marker.setLatLng(newLatLng);

                    if (vehicle.bearing !== undefined) {
                        marker.setRotationAngle(vehicle.bearing);
                    }
                    markersUpdated++;
                } else {
                    const iconUrl = vehicle.icon_url || 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png';

                    const icon = L.icon({
                        iconUrl: iconUrl,
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    });

                    const marker = L.marker([vehicle.lat, vehicle.lng], {
                        icon: icon,
                        rotationAngle: vehicle.bearing || 0,
                        rotationOrigin: 'center center'
                    }).addTo(map);

                    const popupContent = `
                        <div class="vehicle-popup">
                            <h3>üöï ${vehicle.category_name || '‡πÅ‡∏ó‡πá‡∏Å‡∏ã‡∏µ‡πà'}</h3>
                            <p><strong>‡∏£‡∏´‡∏±‡∏™:</strong> ${vehicle.id}</p>
                            <p><strong>‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á:</strong> ${vehicle.lat.toFixed(6)}, ${vehicle.lng.toFixed(6)}</p>
                            <p><strong>‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á:</strong> ${vehicle.bearing || 0}¬∞</p>
                            <p><strong>‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà:</strong> ${formatLocationLabel(vehicle.source_location)}</p>
                        </div>
                    `;
                    marker.bindPopup(popupContent);

                    markers[vehicle.id] = marker;
                    markersCreated++;
                }
            });

            let markersRemoved = 0;
            Object.keys(markers).forEach((id) => {
                if (!currentIds.has(id)) {
                    map.removeLayer(markers[id]);
                    delete markers[id];
                    markersRemoved++;
                }
            });

            addDebugLog(`üéØ Markers: +${markersCreated} new, ~${markersUpdated} updated, -${markersRemoved} removed. Total: ${Object.keys(markers).length}`);
        }

        function updateStats(displayCount, locationsCount, fetchTime, totalCount = displayCount) {
            const vehicleCountEl = document.getElementById('vehicle-count');
            const vehicleSubtextEl = document.getElementById('vehicle-count-subtext');
            if (vehicleCountEl) {
                vehicleCountEl.textContent = totalCount !== displayCount ? `${displayCount} / ${totalCount}` : `${displayCount}`;
            }
            if (vehicleSubtextEl) {
                vehicleSubtextEl.textContent = totalCount !== displayCount ? 'visible / total' : 'visible';
            }

            const locationCountEl = document.getElementById('location-count');
            if (locationCountEl) {
                locationCountEl.textContent = locationsCount;
            }

            const fetchTimeEl = document.getElementById('fetch-time');
            const fetchTimeValue = Number.isFinite(fetchTime) ? fetchTime : parseFloat(fetchTime) || 0;
            if (fetchTimeEl) {
                fetchTimeEl.textContent = fetchTimeValue.toFixed(2);
            }

            const now = new Date();
            const timeStr = now.toLocaleTimeString('th-TH', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const lastUpdateEl = document.getElementById('last-update');
            if (lastUpdateEl) {
                lastUpdateEl.textContent = timeStr;
            }
        }

        // Performance indicator
        let lastUpdateTime = Date.now();
        setInterval(() => {
            const elapsed = (Date.now() - lastUpdateTime) / 1000;
            if (elapsed > 10) {
                addDebugLog(`‚ö†Ô∏è No update for ${elapsed.toFixed(0)}s`);
            }
        }, 5000);

        addDebugLog('üöÄ System ready, waiting for data...');
    </script>
</body>
</html>